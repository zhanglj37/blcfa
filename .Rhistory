install.packages("ggplot2")
install.packages("devtools")
install.packages("MplusAutomation")
library(devtools)
install_github("zhanglj37/sampleMplus")
install_github("zhanglj37/blcfa")
library(devtools)
install_github('zhanglj37/blcfa')
setwd("D:/0_sci/1_paper/20_lasso_cfa/Lasso_users' guide/R package/test2")
library(blcfa)
filename = system.file("extdata", "simu_data1.txt", package = "blcfa")
varnames<-c(paste("y", 1:10, sep = ""))
usevar<-c(paste("y", 1:10, sep = ""))
myModel<-'
f1 =~ y1 + y2 + y3 + y4 + y5
f2 =~ y6 + y7 + y8 + y9 + y10
'
set.seed(1)
MCMAX = 2000
N.burn = 1000
bloutput =TRUE
interval = TRUE
category=FALSE
point=5
ms=999
estimation = "ml"
nthin<-1  ## MCMC algorithm sampling interval
CNUM<-2   ## number of chain
dataset <- read_data(filename, varnames, usevar)
### source("read_model.r")
N <- nrow(dataset)    # Sample size (N)
NY <- ncol(dataset)	 # Number of items (p)
if (is.matrix(myModel))
{
IDY0 = myModel
NZ <- ncol(IDY0)
}else{
### source("read_model.r")
mmvarorigin<-read_model(myModel) ## IDY0 = myModel
mmvar<-mmvarorigin[2:length(mmvarorigin)] # List: includes factors and variables under each factor
factorname<-mmvarorigin[[1]]   # names of factors
numw<-length(mmvar)   # num of factors
mmvar_loc<-cfa_loc(mmvar,dataset)  # location of indicators
NZ<-numw  # Number of factors (q)
IDY0<-IDY_matrix(dataset,mmvar,mmvar_loc)
}
## record ms values as NA for standarizing data
dataset_noms <- mark_na(N, NY, dataset, ms)
Y <- read_data2(dataset_noms)  # standarized
###  prior + init + data -> posterior (gibbs sampling) ############################
### source("ind.R")
### source("EPSR_set_int.R")
### source("read_data.R")
### source("Gibbs.R")
cat("The program is running. See 'log.txt' for details.  \n")
set.seed(1)
#**************** Parallel computation ********************
ncores <- 1
if(detectCores()-1 > 1)	{
ncores <- 2
}
#switch between %do% (serial) and %dopar% (parallel)
if (ncores == 1){  #serial
`%is_par%` <- `%do%`
}else{  #parallel
`%is_par%` <- `%dopar%`
cl <- makeCluster(ncores)
registerDoParallel(cores = ncores)
}
writeLines(c(""), "log.txt") #create or clear the log file recording the ouput of foreach loop
parList <- foreach (CIR = 1:CNUM,
.packages = c("MASS", "statmod", "MCMCpack"),
.export = c("IDY_matrix", "set_ly_int", "gibbs_fun")) %is_par%
{
## Calculate the epsr value by running two chains with two kind of initial values
IDMU<-rep(1,NY)
LY_int <- set_ly_int(CIR, IDY0)
IDY = IDY0
IDY[which(IDY0==9)] = 0
sink("log.txt", append=TRUE) # divert the output to the log file
chainlist <- gibbs_fun(MCMAX, NZ, NY, N, Y, LY_int, IDY0, IDY,
nthin, N.burn, CIR)
sink() #revert output back to the console
list(chainlist, IDY, IDMU) #return chainlist, IDY, IDMU to parList
}
if(ncores > 1) stopCluster(cl)
#************************Stop Parallel******************************
#***********access the parameter************
chain1 <- parList[[1]][[1]]
chain2 <- parList[[2]][[1]]
IDY <- parList[[1]][[2]]
IDMU <- parList[[1]][[3]]
#*******************************************
#***********caculate_results************
### source("caculate_results.r")
### source("HPD.R")
### source("sigpsx.r")
### source("EPSR_caculate.r")
### source("write_mplus.r")
resultlist <- caculate_results(chain2, CNUM, MCMAX, NY, NZ, N.burn, nthin, IDMU, IDY)
hpdlist <- hpd_fun(chain2, NZ, NY, N, IDY)
sigpsx_list <- sig_psx_fun(NZ, NY, dataset, resultlist, hpdlist, interval)
sigly_list <- sig_ly_fun(dataset, resultlist, hpdlist, IDY, interval)
epsrlist <- caculate_epsr(MCMAX, N.burn, CNUM, NY, NZ, chain1, chain2)
convergence = epsrlist$convergence
epsr = epsrlist$epsr
cat("Gibbs sampling ended up, specific results are being calculated.  \n")
#***********generate_output ************
if (convergence)
{
if (bloutput)
{
write_results(MCMAX,N.burn,NZ,NY,resultlist,hpdlist,sigpsx_list,sigly_list,
epsr,usevar,IDMU,IDY)
}
ismissing <- impute_ms(Y, NY, N, chain2, N.burn, MCMAX)
estimation = tolower(estimation)
if (estimation == 'bayes' || estimation == 'bayesian')
{
write_mplus_bayes(varnames,usevar,filename,sigpsx_list,sigly_list,IDY0,ismissing)
}else{
write_mplus_ml(varnames,usevar,filename,sigpsx_list,sigly_list,IDY0,ismissing)
}
}else{
cat('Error: Failed to satisfy the convergence criterion. Check the epsr graph and increase the values of N.burn and MCMAX.  \n')
EPSR_figure(epsr, N.burn)
}
if (bloutput)
{
write_results(MCMAX,N.burn,NZ,NY,resultlist,hpdlist,sigpsx_list,sigly_list,
epsr,usevar,IDMU,IDY)
}
ismissing <- impute_ms(Y, NY, N, chain2, N.burn, MCMAX)
estimation = tolower(estimation)
if (estimation == 'bayes' || estimation == 'bayesian')
{
write_mplus_bayes(varnames,usevar,filename,sigpsx_list,sigly_list,IDY0,ismissing)
}else{
write_mplus_ml(varnames,usevar,filename,sigpsx_list,sigly_list,IDY0,ismissing)
}
write_mplus_ml(varnames,usevar,filename,sigpsx_list,sigly_list,IDY0,ismissing)
write_mplus_bayes(varnames,usevar,filename,sigpsx_list,sigly_list,IDY0,ismissing)
## run
path_detect = Sys.getenv("PATH")
path_detect = tolower(path_detect)
if (str_detect(path_detect,'mplus')){
runModels("blcfa_ml.inp")
}else{
print('Error: Failed to run the Mplus software, check whether the environment variables of your computer include the path of Mplus')
}
if(file.exists("Mplus Run Models.log"))
{
file.remove("Mplus Run Models.log")
}
file_exsist = file.exists("Mplus Run Models.log")
if(file_exsist)
{
file.remove("Mplus Run Models.log")
}
## run
path_detect = Sys.getenv("PATH")
path_detect = tolower(path_detect)
if (str_detect(path_detect,'mplus')){
runModels("blcfa_ml.inp")
}else{
print('Error: Failed to run the Mplus software, check whether the environment variables of your computer include the path of Mplus')
}
file_exsist = file.exists("Mplus Run Models.log")
if(file_exsist)
{
file.remove("Mplus Run Models.log")
}
setwd("D:/0_sci/1_paper/20_lasso_cfa/Lasso_users' guide/R package/blcfa")
build()
install.packages("D:/0_sci/1_paper/20_lasso_cfa/Lasso_users' guide/R package/blcfa_0.1.0.tar.gz", repos = NULL, type = "source")
